import { Component, OnInit, TrackByFunction, inject } from '@angular/core';
import { FormBuilder, FormGroup, FormControl, ReactiveFormsModule, FormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { MatRadioModule } from '@angular/material/radio';
import { MatSliderModule } from '@angular/material/slider';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { RespuestasService } from '../../../services/respuestas.service';
import { PlanesIntervencionService } from '../../../services/plan-intervencion.service';
import { Router } from '@angular/router';

@Component({
  selector: 'app-add-respuesta',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    MatRadioModule,
    MatSliderModule,
    MatButtonModule,
    MatFormFieldModule,
    MatSelectModule
  ],
  templateUrl: './add-respuesta.component.html',
  styleUrl: './add-respuesta.component.scss',
})
export class AddRespuestaComponent implements OnInit {
  respuestaForm!: FormGroup;
  planes: any[] = [];
  evaluaciones: any[] = [];
  preguntas: any[] = [];
  respuestas: { [preguntaId: number]: any[] } = {};
  observaciones: { [preguntaId: number]: FormControl } = {};
  miFormulario: FormGroup;

  private fb: FormBuilder = inject(FormBuilder);
  private PlanesIntervencionService = inject(PlanesIntervencionService);
  private respuestaService = inject(RespuestasService);
  trackById!: TrackByFunction<any>;
  trackByPregunta!: TrackByFunction<any>;
  trackByRespuesta!: TrackByFunction<any>;
  trackBySubPregunta!: TrackByFunction<any>;
  trackByOpcion!: TrackByFunction<any>;

  constructor(private router: Router) {
    this.miFormulario = this.fb.group({
      plan_id: ['', Validators.required],
      evaluacion_id: ['', Validators.required]
    });
  }

  ngOnInit() {
    this.inicializarFormulario();
    this.cargarPlanes();
  }

  /** üìå Inicializar formulario */
  inicializarFormulario() {
    this.respuestaForm = this.fb.group({
      plan_id: ['', Validators.required],
      evaluacion_id: ['', Validators.required]
    });
  }

  /** üìå Cargar planes de intervenci√≥n */
  cargarPlanes() {
    this.PlanesIntervencionService.getPlanes().subscribe({
      next: (data) => {
        if (Array.isArray(data)) {
          this.planes = data;
          console.log('‚úÖ Planes obtenidos:', this.planes);
        } else {
          console.error('‚ö†Ô∏è La respuesta no es un array:', data);
        }
      },
      error: (err) => console.error('‚ùå Error al cargar planes:', err),
    });
  }

/** üìå Cargar evaluaciones al seleccionar un plan */
cargarEvaluaciones(planId: number) {
  this.evaluaciones = [];
  this.preguntas = [];
  this.respuestas = {};

  if (planId) {
    this.PlanesIntervencionService.getEvaluacionesSinRespuestas(planId).subscribe({
      next: (data) => {
        this.evaluaciones = data.evaluaciones || [];
        console.log('‚úÖ Evaluaciones filtradas:', this.evaluaciones);
      },
      error: (err) => console.error('‚ùå Error al cargar evaluaciones:', err),
    });
  }
}

  /** üìå Cargar preguntas al seleccionar una evaluaci√≥n */
  cargarPreguntas(evaluacionId: number) {
    this.preguntas = [];
    this.respuestas = {};
    this.observaciones = {};

    if (evaluacionId) {
      const evaluacion = this.evaluaciones.find(e => e.id === evaluacionId);
      if (evaluacion && Array.isArray(evaluacion.preguntas)) {
        this.preguntas = evaluacion.preguntas;
        this.preguntas.forEach(pregunta => {
          this.respuestas[pregunta.id] = [];
          this.observaciones[pregunta.id] = new FormControl('');
        });
        console.log('‚úÖ Preguntas cargadas:', this.preguntas);
      } else {
        console.warn('‚ö†Ô∏è No hay preguntas disponibles para la evaluaci√≥n seleccionada.');
      }
    }
  }

  /** üìå Agregar escala Likert editable */
  agregarEscalaLikertEditable(preguntaId: number) {
    if (!this.respuestas[preguntaId]) {
      this.respuestas[preguntaId] = [];
    }

    const escalaLikert = this.respuestas[preguntaId].find(res => res.tipo === 'likert');
    
    if (!escalaLikert) {
      this.respuestas[preguntaId].push({
        tipo: 'likert',
        subpreguntas: [
          { texto: '', opciones: this.obtenerOpcionesLikert() }
        ]
      });
    } else {
      console.warn(`‚ö†Ô∏è La pregunta ${preguntaId} ya tiene una escala Likert.`);
    }
  }

  /** üìå Obtener opciones por defecto para la Escala Likert */
  obtenerOpcionesLikert() {
    return [
      { label: 'No estoy de acuerdo', control: new FormControl('') },
      { label: 'Estoy un poco de acuerdo', control: new FormControl('') },
      { label: 'Estoy de acuerdo', control: new FormControl('') },
      { label: 'Estoy muy de acuerdo', control: new FormControl('') },
      { label: 'Estoy totalmente de acuerdo', control: new FormControl('') },
      { label: 'S√≠', control: new FormControl('') },
      { label: 'No', control: new FormControl('') },
      { label: 'No es cierto', control: new FormControl('') },
      { label: 'En cierta manera o algunas veces', control: new FormControl('') },
      { label: 'Muy cierto o a menudo es cierto', control: new FormControl('') },
      { label: 'No estoy seguro/a', control: new FormControl('') },
      { label: 'Nunca', control: new FormControl('') },
      { label: 'A menudo', control: new FormControl('') },
      { label: 'A veces', control: new FormControl('') },
      { label: 'Siempre', control: new FormControl('') },
      { label: 'Una vez', control: new FormControl('') },
      { label: 'Dos o tres veces', control: new FormControl('') },
      { label: 'M√°s de tres veces', control: new FormControl('') },
      { label: 'No s√© / No aplica', control: new FormControl('') },
      { label: 'No s√©', control: new FormControl('') }
    ];
  }

  /** üìå Agregar nueva opci√≥n a la Escala Likert */
  agregarOpcionLikert(preguntaId: number, escala: any) {
    if (!escala || !Array.isArray(escala.subpreguntas)) {
      console.error(`‚ùå No se encontr√≥ la escala para la pregunta ${preguntaId}.`);
      return;
    }

    const nuevaOpcion = { label: 'Nueva Opci√≥n', control: new FormControl('') };

    escala.subpreguntas.forEach((subpregunta: any) => {
      if (Array.isArray(subpregunta.opciones)) {
        subpregunta.opciones.push(nuevaOpcion);
      }
    });
  }

  /** üìå Editar texto de una opci√≥n de la Escala Likert */
  editarOpcionLikert(opcion: any, nuevoValor: string) {
    if (!nuevoValor.trim()) {
      console.warn('‚ö†Ô∏è El nuevo valor no puede estar vac√≠o.');
      return;
    }
    opcion.label = nuevoValor;
  }

  /** üìå Eliminar una opci√≥n de la Escala Likert */
  eliminarOpcionLikert(subpregunta: any, opcion: any) {
    if (!subpregunta || !Array.isArray(subpregunta.opciones)) {
      console.error('‚ùå No se puede eliminar la opci√≥n, la subpregunta no es v√°lida.');
      return;
    }

    subpregunta.opciones = subpregunta.opciones.filter((opt: any) => opt !== opcion);
  }

  /** üìå Agregar una nueva subpregunta manteniendo las opciones previas */
  agregarSubPreguntaLikert(preguntaId: number, escala: any) {
    if (!escala || !Array.isArray(escala.subpreguntas) || escala.subpreguntas.length === 0) {
      console.error(`‚ùå No se pueden agregar subpreguntas, la escala de la pregunta ${preguntaId} no tiene opciones.`);
      return;
    }

    escala.subpreguntas.push({
      texto: '',
      opciones: escala.subpreguntas[0].opciones.map((opcion: any) => ({
        label: opcion.label,
        control: new FormControl('')
      }))
    });
  }

  /** üìå Eliminar una subpregunta espec√≠fica dentro de la Escala Likert */
  eliminarSubPreguntaLikert(preguntaId: number, escala: any, subpregunta: any) {
    if (!escala || !Array.isArray(escala.subpreguntas)) {
      console.error(`‚ùå No se puede eliminar la subpregunta, la escala de la pregunta ${preguntaId} no es v√°lida.`);
      return;
    }

    escala.subpreguntas = escala.subpreguntas.filter((sp: any) => sp !== subpregunta);
  }

    /** üìå Guardar respuestas */
    guardarRespuestas() {
      const requestBody = {
        evaluacion_id: this.miFormulario.get('evaluacion_id')?.value
          ? Number(this.miFormulario.get('evaluacion_id')?.value)
          : null,
    
        respuestas: this.preguntas.map((pregunta) => {
          const respuesta = this.respuestas[pregunta.id]?.[0];
    
          return {
            pregunta_id: pregunta.id ? Number(pregunta.id) : null,  // ‚úÖ Asegurar `pregunta_id`
            tipo: respuesta?.tipo ?? null,
            respuesta: respuesta?.valor !== undefined && respuesta?.valor !== null
              ? String(respuesta.valor)
              : null,
            observaciones: respuesta?.observaciones ?? null,
            opciones: respuesta?.opciones?.length ? respuesta.opciones : null,
            subpreguntas: respuesta?.subpreguntas?.length ? respuesta.subpreguntas : null
          };
        }).filter((r) => r.pregunta_id !== null && r.tipo !== null) // ‚úÖ Filtrar respuestas inv√°lidas
      };
    
      console.log("üì§ Enviando datos a la API:", JSON.stringify(requestBody, null, 2));
    
      if (!requestBody.evaluacion_id) {
        console.error("‚ùå Error: `evaluacion_id` no puede ser null.");
        return;
      }
    
      if (requestBody.respuestas.length === 0) {
        console.error("‚ùå Error: No hay respuestas v√°lidas para enviar.");
        return;
      }
    
      // Asegurarte de pasar las respuestas de manera adecuada:
      // Cambia esto si 'this.respuestas' no es un array.
      const respuestasFormateadas = Object.values(this.respuestas).flat(); // Convertir en un array plano
    
      this.respuestaService.guardarRespuestas(requestBody, respuestasFormateadas).subscribe({
        next: (response: any) => {
          console.log("‚úÖ Respuestas guardadas con √©xito", response);
          this.router.navigate(['admin/gestion-respuestas/listar']); // ‚úÖ Redirecci√≥n despu√©s de √©xito
        },
        error: (error: any) => {
          console.error("‚ùå Error al guardar respuestas:", error);
        }
      });
    }
    
     
    /** üìå Agregar Respuesta de Texto */
    agregarRespuestaTexto(preguntaId: number) {
      if (!this.respuestas[preguntaId]) {
        this.respuestas[preguntaId] = [];
      }
      this.respuestas[preguntaId].push({ tipo: 'texto', valor: '' });
    }

    /** üìå Agregar Barra de Satisfacci√≥n */
    agregarBarraSatisfaccion(preguntaId: number) {
      if (!this.respuestas[preguntaId]) {
        this.respuestas[preguntaId] = [];
      }
      this.respuestas[preguntaId].push({ tipo: 'barra_satisfaccion', valor: 5 }); // Inicializa con valor por defecto
    }

    /** üìå Agregar Opci√≥n S√≠/No */
    agregarOpcionSiNo(preguntaId: number) {
      if (!this.respuestas[preguntaId]) {
        this.respuestas[preguntaId] = [];
      }
      this.respuestas[preguntaId].push({
        tipo: 'si_no',
        valor: ''
      });
    }

    /** üìå Agregar Opci√≥n S√≠/No/No estoy seguro */
    agregarOpcionSiNoNoEstoySeguro(preguntaId: number) {
      if (!this.respuestas[preguntaId]) {
        this.respuestas[preguntaId] = [];
      }

      this.respuestas[preguntaId].push({
        tipo: 'si_no_noestoyseguro',
        valor: '',
        opciones: [
          { label: 'S√≠', value: 'si' },
          { label: 'No', value: 'no' },
          { label: 'No estoy seguro', value: 'no_estoy_seguro' }
        ]
      });
    }

    /** üìå Agregar Opci√≥n de 5 Emojis */
    agregarOpcion5emojis(preguntaId: number) {
      if (!this.respuestas[preguntaId]) {
        this.respuestas[preguntaId] = [];
      }

      this.respuestas[preguntaId].push({
        tipo: '5emojis',
        valor: '',
        opciones: [
          { label: 'Emoji 1', value: 'Emoji 1' },
          { label: 'Emoji 2', value: 'Emoji 2' },
          { label: 'Emoji 3', value: 'Emoji 3' },
          { label: 'Emoji 4', value: 'Emoji 4' },
          { label: 'Emoji 5', value: 'Emoji 5' }
        ]
      });
    }

    /** üìå Eliminar una respuesta agregada */
    eliminarRespuesta(preguntaId: number, respuesta: any) {
      if (!this.respuestas[preguntaId] || !Array.isArray(this.respuestas[preguntaId])) {
        console.warn(`‚ö†Ô∏è No se encontr√≥ la respuesta para la pregunta ${preguntaId}.`);
        return;
      }
      this.respuestas[preguntaId] = this.respuestas[preguntaId].filter(res => res !== respuesta);
    }

    /** üìå Convertir respuesta de texto en opci√≥n */
    convertirASeleccion(preguntaId: number, respuesta: any) {
      if (!respuesta.valor || !respuesta.valor.trim()) {
        console.warn("‚ö†Ô∏è No se puede convertir una respuesta vac√≠a.");
        return;
      }
      respuesta.tipo = 'opcion';
      respuesta.texto = respuesta.valor;
    }

    /** üìå Agregar Input Num√©rico */
    agregarInputNumerico(preguntaId: number) {
      if (!this.respuestas[preguntaId]) {
        this.respuestas[preguntaId] = [];
      }
      this.respuestas[preguntaId].push({ tipo: 'numero', valor: '' });
    }

    /** üìå Convertir texto a una opci√≥n seleccionable */
    convertirATipoOpcion(preguntaId: number, respuesta: any) {
      if (!respuesta.valor || !respuesta.valor.trim()) {
        alert("‚ö†Ô∏è Debes ingresar un texto antes de convertirlo en una opci√≥n.");
        return;
      }

      this.respuestas[preguntaId] = this.respuestas[preguntaId].map(r => {
        if (r === respuesta) {
          return {
            tipo: 'opcion',
            opciones: [
              { label: respuesta.valor, control: new FormControl('') }
            ]
          };
        }
        return r;
      });
    }

}